## ❗ 브라우저의 주요 기능

사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것

자원의 형태: 보통 HTML 문서지만 PDF, 이미지 등 다른 형태도 가능

자원의 주소는 URI(Uniform Resource Identifier)에 의해 정해짐

▶️ URI란? [참고 주소](https://en.wikipedia.org/wiki/Uniform_Resource_Identifier)

### 동작 과정 개요

> 1. 렌더링에 필요한 리소스(HTML, CSS, JS, 이미지, 폰트 등)를 서버에 요청
>    <br>
> 2. 렌더링 엔진

- 서버에서 응답한 HTML, CSS를 파싱해 `DOM`, `CSSOM`을 생성
- 이들을 결합해 `렌더트리` 생성
  <br>

3. 자바스크립트 엔진

- 서버에서 응답한 JS를 파싱해 `AST`(Abstract Syntax Tree)를 생성
- `AST`를 바이트코드로 변환하여 실행
- 이때 JS는 `DOM API`를 사용해 `DOM`, `CSSOM`을 변경할 수 있음
- 변경된 `DOM`, `CSSOM`은 `렌더 트리`에 결합
  <br>

4. 렌더트리를 기반으로 HTML 요소의 위치와 크기를 계산하고 브라우저 화면에 HTML 요소를 페인팅

<br>

## 🌐 브라우저의 기본 구조

1. 사용자 인터페이스
2. 브라우저 엔진
3. 렌더링 엔진
4. 통신
5. UI 백엔드
6. 자바스크립트 해석기
7. 자료 저장소

참고로 크롬은 대부분 브라우저와 달리 각 탭마다 별도의 렌더링 엔진 인스턴스를 유지하고, 각 탭은 독립된 프로세스로 처리된다.

<br>

## ⚙️ 렌더링 엔진

### 역할

요청 받은 내용을 브라우저 화면에 표시하는 일 (렌더링)

<br>

### 종류

가장 많이 쓰이는 브라우저의 렌더링 엔진은 다음과 같다.

- Gecko(파이어폭스)
- Webkit(사파리, 크롬)

<br>

### 동작 과정

#### 1. HTML 파싱 + DOM 트리 구축

서버가 응답한 HTML 문서는 문자열로만 이루어진 순수한 텍스트이다. 이 텍스트를 시각적인 픽셀로 렌더링 하기 위해 브라우저는 다음과 같은 과정을 거친다.

> 1. 서버는 브라우저가 요청한 HTML 파일을 읽어들여 메모리에 저장한 후 메모리에 저장된 2진수 기반의 데이터를 인터넷을 통해 응답한다.
> 2. 브라우저는 서버에 요청한 HTML을 2진수 기반의 데이터로 응답받는다.

- 응답 받은 HTML 문서는 meta 태그의 charset 어트리뷰트에 의해 지정된 인코딩 방식을 기준으로 문자열로 변환
- 문자열로 변환된 HTML 문서를 읽어들여 코드의 최소 단위인 `토큰`들로 분해
- 각 토큰들을 객체로 변환해 `노드`를 생성 (`토큰`의 내용에 따라 문서/요소/어트리뷰트/텍스트 노드가 생성됨)

3. HTML 요소의 콘텐츠 영역에는 텍스트 뿐 아니라 다른 요소들이 포함될 수 있어 이러한 중첩 관계에 의해 부자 관계가 형성되고, 이를 트리 자료구조(DOM)로 구성한다.

<br>

#### ✅ 예시

```html
<html>
  <body>
    <p>Hello World</p>
    <div><img src="example.png" /></div>
  </body>
</html>
```

위 마크업은 아래의 DOM 트리로 변환할 수 있다.

![](https://velog.velcdn.com/images/kyw0716/post/cc7ed63c-466d-4402-890a-15a406535029/image.png)

(출처: [NaverD2](https://d2.naver.com/helloworld/59361))

HTML을 위와 같이 DOM 트리로 변환하는 과정에서 유효하지 않은 HTML 구문을 파싱하게 되면 브라우저가 모든 오류 구문을 교정하는 과정을 거치게 된다.

<br>

#### 2. CSS 파싱과 CSSOM 생성

렌더링 엔진이 DOM을 생성하다가 `link`, `style`등의 태그를 만나면 DOM 생성을 일시 중단한다. 그리고 다음과 같은 과정을 거친다.

> 1. `link`태그의 href 어트리뷰트에 지정된 CSS 파일을 서버에 요청해 로드한다.
> 2. 로드한 CSS 파일을 HTML과 동일한 파싱 과정(바이트 -> 문자 -> 토큰 -> 노드 -> CSSOM)을 거치며 CSSOM 생성
> 3. CSS 파싱이 완료되면 DOM 생성이 중단된 지점부터 다시 HTML 파싱 재개

<br>

#### ✅ 예시

CSS 파일은 CSS 규칙을 포함한 스타일 시트 객체로 파싱된다. CSS 규칙 객체는 선택자, 선언 객체를 포함한다.

![](https://velog.velcdn.com/images/kyw0716/post/9c4f76df-6259-4f0a-ab3d-eb65ce903b5f/image.png)

(출처: [NaverD2](https://d2.naver.com/helloworld/59361))

<br>

#### 3. 렌더 트리 구축

렌더링 엔진은 서버로부터 응답된 HTML, CSS를 파싱해 `DOM`, `CSSOM`을 생성하고, 이를 결합해 `렌더 트리`를 생성한다.

렌더 트리가 완성되면 각 HTML 요소의 레이아웃을 계산하는데 사용되며, 브라우저 화면에 픽셀을 렌더링하는 페인팅 처리에 입력된다.

브라우저의 렌더링 과정은 다음과 같은 이유에 의해 반복해서 실행될 수 있다.

- 자바스크립트에 의한 노드 추가, 삭제
- 브라우저 창의 리사이징에 의한 뷰포트 크기 변경
- HTML 요소의 레이아웃에 변경을 발생시키는 width/height, margin, padding, border, position, top/right/bottom/left 등의 스타일 변경

위 과정들은 레이아웃의 계산과 페인팅을 다시 실행 시키므로 성능에 악영향을 미칠 수 있다.

#### ❗ 참고

DOM트리가 구축되는 동안 브라우저는 렌더 트리를 구축한다. 이러한 렌더 트리의 구성 요소를 파이어폭스 에서는 프레임(frames), 웹킷에서는 렌더러(renderer)라고 부른다. 각 렌더러는 너비, 높이, 위치와 같은 기하학적 정보를 포함한다.

렌더러 기본 객체 구성

```cpp
class RenderObject { virtual
  void layout(); virtual
  void paint(PaintInfo); virtual
  void rect repaintRect();
  Node * node; //the DOM node
  RenderStyle * style; // the computed style
  RenderLayer * containgLayer; //the containing z-index layer
}
```

렌더러가 생성되어 처음 트리에 추가될 때 크기와 위치 정보를 갖고 있지 않는데 이런 값을 계산해주는 것을 배치 또는 리플로우라고 부른다. 배치는 크기 변경 또는 렌더러 위치 변화에 의해 실행되는 경우 렌더러의 크기를 다시 계산하지 않고 캐시에서 불러오는 방식으로 최적화 되어 있다.

배치의 과정은 다음과 같다.

> 부모 렌더러 너비 결정 -> 자식 검토 (자식 렌더러 배치, 자식 높이 계산) -> 자식의 누적 높이, 여백, 패딩등을 통해 부모 높이 결정

<br>

#### 4. 렌더트리 그리기

그리기 단계에서는 화면에 내용을 표시하기 위한 렌더 트리의 탐색이 이루어지고, 렌더러의 `paint`메서드가 호출된다.

<br>

## ⚙️ 자바스크립트 엔진

### 1. 자바스크립트 파싱과 실행

`DOM`은 HTML 문서의 구조, 정보 뿐 아니라 이를 변경할 수 있는 프로그래밍 인터페이스로서 `DOM API`를 제공한다.

렌더링 엔진은 HTML을 한줄씩 순차적으로 파싱해 DOM을 생성한다. 이때 `script` 태그를 만나면 `DOM` 생성을 일시 중단한다.

브라우저는 `DOM` 생성이 중단된 이후 script 태그의 src 어트리뷰트에 지정된 자바스크립트 파일을 서버에 요청하고, 이를 파싱하기 위해 렌더링 엔진이 갖고 있던 제어권을 자바스크립트 엔진에 넘긴다.

제어권을 넘겨받은 자바스크립트 엔진은 다음과 같은 과정을 거쳐 자바스크립트 코드를 파싱해 CPU가 이해할 수 있는 저수준 언어로 변환한 후 실행한다.

> 1. 단순한 문자열이 JS 코드를 어휘분석하여 토큰들로 분해
> 2. 토큰들의 집합을 구문분석하여 `AST`생성
> 3. `AST`를 기반으로 인터프리터가 실행할 수 있는 중간코드인 `바이트 코드`를 생성하여 실행

<br>

### 2. 리플로우와 리페인트

앞서 이야기한 것처럼 JS는 `DOM API`를 이용해 `DOM`, `CSSOM`을 변경할 수 있다.

이때 변경된 `DOM`, `CSSOM`은 다시 `렌더 트리`로 결합되고, 변경된 `렌더 트리`를 기반으로 레이아웃 계산, 페인트 과정을 거쳐 브라우저의 화면을 다시 렌더링 한다. 이 과정을 `리플로우`, `리페인트`라고 한다.

- 리플로우: 레이아웃의 재계산을 지칭하는 용어. 노드 추가/삭제, 요소의 크기/위치 변경, 윈도우 리사이징에 의해 발생
- 리페인트: 재결합된 렌더 트리를 기반으로 다시 페인트를 함

리플로우, 리페인트는 항상 순차적으로 일어나지 않는다. 레이아웃에 영향이 없는 변경은 리페인드만 일어나게 된다. ex) css 색상 변경

<br>

### 3. 자바스크립트 파싱에 의한 HTML 파싱 중단

렌더링 엔진이 `DOM`을 생성하는 도중에 script 태그를 만나게 되면 DOM의 생성이 중단된다.

따라서 script 태그의 위치에 따라 `DOM` 생성이 지연될 수 있으므로 script 태그의 위치는 중요하다.

<br>

#### 주의사항

`DOM`이 완성되지 않은 상태에서 JS가 `DOM`을 조작하면 에러가 발생할 수 있다.

자바스크립트 로딩/파싱/실행으로 인해 페이지 로딩 시간이 연장될 수 있다.

#### 권고

body의 가장 아래에 자바스크립트를 위치시키면 렌더링 엔진의 `DOM` 생성이 완료된 이후에 자바스크립트 엔진에게 제어권이 넘어가므로 이를 권장한다.

<br>

### 4. script 태그의 async/defer 어트리뷰트

`DOM` 생성이 중단되는 것을 방지하기 위해 async/defer 등과 같은 어트리뷰트가 등장하게 되었다.

#### async

비동기적으로 script를 로드하는 방식으로, 먼저 로드된 스크립트가 먼저 실행되게 된다. 따라서 각 script의 로드 순서를 보장할 수 없기 때문에 순서를 보장받아야 하는 script 태그에는 async 어트리뷰트를 사용하면 안된다.

#### defer

DOM의 생성이 완료된 직후 DOMContentLoaded 이벤트가 발생해 이때 script의 로드가 시작된다.

<br>

## 📌 참고

> - [NaverD2](https://d2.naver.com/helloworld/59361)

- 모던 자바스크립트 Deep Dive

웹킷 동작 과정 (출처: [NaverD2](https://d2.naver.com/helloworld/59361))

![](https://velog.velcdn.com/images/kyw0716/post/0d640f7c-8a45-440f-9d55-151898e27e7b/image.png)

게코 동작 과정 (출처: [NaverD2](https://d2.naver.com/helloworld/59361))

![](https://velog.velcdn.com/images/kyw0716/post/b7444500-61ae-4e15-8a53-dd9c7d03aaf4/image.png)

<br>

## 🎁 추가 학습 주제

- 문서 파싱
  - 파싱 트리, 문법 트리, 컴파일 과정
  - 파서 종류
    - 파싱 알고리즘
    - [HTML 파싱 알고리즘 참고](https://html.spec.whatwg.org/multipage/parsing.html)
    - 토큰화 알고리즘
- 브라우저의 오류 처리 (유효하지 않은 HTML)
- 렌더링 엔진별 동작 과정
